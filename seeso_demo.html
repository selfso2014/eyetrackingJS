<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SeeSo Web Eye-Tracking Demo (Single HTML)</title>

  <!-- (선택) 일부 환경에서 crossOriginIsolated가 필요할 수 있어 넣어둠.
       서버가 헤더를 덮어쓰면 적용되지 않을 수 있음. -->
  <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin" />
  <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp" />

  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial;
      background: #0b0f14; color: #e6edf3;
    }
    header {
      display: flex; gap: 12px; align-items: center; justify-content: space-between;
      padding: 12px 14px; border-bottom: 1px solid #1f2a37; background: #0b0f14;
      position: sticky; top: 0; z-index: 10;
    }
    header .left { display:flex; gap:10px; align-items:center; }
    .badge { font-size: 12px; padding: 3px 8px; border: 1px solid #334155; border-radius: 999px; color: #cbd5e1; }
    .ok { border-color:#14532d; color:#bbf7d0; }
    .warn { border-color:#7c2d12; color:#fed7aa; }
    .err { border-color:#7f1d1d; color:#fecaca; }

    main { display: grid; grid-template-columns: 360px 1fr; gap: 14px; padding: 14px; }
    @media (max-width: 980px) { main { grid-template-columns: 1fr; } }

    .card {
      border: 1px solid #1f2a37; border-radius: 14px; padding: 12px; background: #0f1621;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .card h3 { margin: 0 0 10px; font-size: 14px; color:#cbd5e1; font-weight: 700; }
    .row { display:flex; gap: 8px; flex-wrap: wrap; }
    button {
      background:#111827; color:#e5e7eb; border:1px solid #334155; border-radius: 10px;
      padding: 10px 12px; cursor:pointer; font-weight: 700; font-size: 13px;
    }
    button:disabled { opacity:.45; cursor:not-allowed; }
    button.primary { background:#1f2937; border-color:#475569; }
    button.danger { background:#2a1313; border-color:#7f1d1d; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; color:#cbd5e1; }
    .kv { display:grid; grid-template-columns: 130px 1fr; gap: 6px 10px; }
    .kv div { padding: 4px 0; border-bottom: 1px dashed rgba(148,163,184,.2); }
    .kv div:nth-child(odd) { color:#94a3b8; }
    .kv div:nth-child(even) { color:#e2e8f0; }

    #log {
      height: 260px; overflow:auto; background:#0b1220; border:1px solid #1f2a37;
      border-radius: 12px; padding: 10px; white-space: pre-wrap; line-height: 1.4;
    }

    /* Stage */
    #stage {
      position: relative; border: 1px solid #1f2a37; border-radius: 14px; background:#05070b;
      min-height: 560px; overflow:hidden;
    }
    #hint {
      position:absolute; left: 12px; top: 12px; right: 12px;
      padding: 10px 12px; border-radius: 12px; background: rgba(15,22,33,.85);
      border:1px solid rgba(51,65,85,.6); color:#e2e8f0; z-index: 2;
    }
    #video {
      position:absolute; right: 12px; bottom: 12px; width: 220px; aspect-ratio: 16/10;
      border-radius: 12px; border:1px solid rgba(51,65,85,.7); background:#000; z-index: 2;
      opacity: .92;
    }
    #gazeDot, #calibDot {
      position: absolute; width: 16px; height: 16px; border-radius: 999px; transform: translate(-50%, -50%);
      pointer-events:none; z-index: 3;
    }
    #gazeDot { background: rgba(34,197,94,.95); box-shadow: 0 0 0 6px rgba(34,197,94,.18); display:none; }
    #calibDot { background: rgba(147,51,234,.95); box-shadow: 0 0 0 10px rgba(147,51,234,.18); display:none; }

    #crosshair {
      position:absolute; left:0; top:0; right:0; bottom:0; pointer-events:none; opacity:.08;
      background-image:
        linear-gradient(to right, rgba(226,232,240,.35) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(226,232,240,.35) 1px, transparent 1px);
      background-size: 40px 40px;
      z-index: 1;
    }

    .muted { color:#94a3b8; }
    .small { font-size: 12px; }
    .sep { height: 10px; }
  </style>

  <!-- SeeSo Web SDK (CDN) -->
  <!-- 샘플 repo README에서 안내되는 CDN 방식(환경에 따라 URL이 변경될 수 있음) -->
  <script src="https://cdn.seeso.io/seeso.js"></script>
</head>

<body>
<header>
  <div class="left">
    <div style="font-weight:900;">SeeSo Web Eye-Tracking Demo</div>
    <span id="secureBadge" class="badge">Secure Context 확인 중...</span>
    <span id="sdkBadge" class="badge">SDK 로딩 확인 중...</span>
  </div>
  <div class="row">
    <button id="btnStart" class="primary">자동 시작 재시도</button>
    <button id="btnCalib">캘리브레이션(5pt) 재시작</button>
    <button id="btnStop" class="danger">중지</button>
  </div>
</header>

<main>
  <section class="card">
    <h3>상태</h3>
    <div class="kv mono">
      <div>Origin</div><div id="kvOrigin"></div>
      <div>HTTPS/localhost</div><div id="kvSecure"></div>
      <div>crossOriginIsolated</div><div id="kvCOI"></div>
      <div>SDK</div><div id="kvSDK"></div>
      <div>Tracking</div><div id="kvTracking"></div>
      <div>Calibration</div><div id="kvCalib"></div>
      <div>Gaze (x,y)</div><div id="kvGaze"></div>
      <div>Debug</div><div id="kvDebug"></div>
    </div>

    <div class="sep"></div>

    <h3>로그</h3>
    <div id="log" class="mono"></div>

    <div class="sep"></div>
    <div class="small muted">
      - 이 파일에는 라이센스키가 포함되어 있어, 배포 시 누구나 확인할 수 있습니다.<br/>
      - 카메라는 브라우저 정책상 HTTPS(또는 localhost)에서만 퍼미션 팝업이 뜹니다. (HTTP/파일열기 불가) :contentReference[oaicite:3]{index=3}
    </div>
  </section>

  <section class="card">
    <h3>시선추적 화면</h3>
    <div id="stage">
      <div id="crosshair"></div>
      <div id="hint" class="small">
        1) 페이지 로드 즉시 카메라 퍼미션 팝업이 뜹니다 → <b>허용</b><br/>
        2) 자동으로 5포인트 캘리브레이션이 시작됩니다 (보라색 점을 응시)<br/>
        3) 완료되면 초록색 점이 시선 위치를 표시합니다
      </div>
      <video id="video" autoplay playsinline muted></video>
      <div id="calibDot"></div>
      <div id="gazeDot"></div>
    </div>
  </section>
</main>

<noscript>
  <div style="padding:16px; color:#fff; background:#7f1d1d;">
    JavaScript가 비활성화되어 있어 실행할 수 없습니다.
  </div>
</noscript>

<script>
  /**********************************************************************
   * 필수: 사용자 제공 라이센스 키 (요청대로 HTML 내부에 포함)
   **********************************************************************/
  const LICENSE_KEY = "dev_1ntzip9admm6g0upynw3gooycnecx0vl93hz8nox";

  /**********************************************************************
   * Secure context 체크 (URL로 접속해도 카메라 팝업이 뜨게 하려면 HTTPS 필요)
   **********************************************************************/
  function isHttpsOrLocalhost() {
    const p = location.protocol;
    const h = location.hostname;
    return (p === "https:" || h === "localhost" || h === "127.0.0.1");
  }

  /**********************************************************************
   * DOM helpers
   **********************************************************************/
  const $ = (id) => document.getElementById(id);
  const logEl = $("log");
  function log(msg) {
    const t = new Date().toISOString().replace("T"," ").replace("Z","");
    logEl.textContent += `[${t}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function setBadge(el, text, cls) {
    el.className = "badge " + (cls || "");
    el.textContent = text;
  }
  function setKV(id, val) {
    $(id).textContent = String(val);
  }

  /**********************************************************************
   * SeeSo namespace/constructor 해석(환경별 글로벌 노출 차이를 방어적으로 처리)
   **********************************************************************/
  function resolveSeesoNamespace() {
    // 가능한 후보들을 최대한 넓게 탐색
    return window.seeso || window.SeeSo || window.Eyedid || window.EyeDid || null;
  }
  function resolveSeesoCtor(ns) {
    if (!ns) return null;
    // ns가 function(ctor)인 경우, 또는 {default: ctor}인 경우 모두 대응
    if (typeof ns === "function") return ns;
    if (typeof ns.default === "function") return ns.default;
    return null;
  }
  function resolveEnum(ns, ctor, enumName) {
    if (ns && ns[enumName]) return ns[enumName];
    if (ctor && ctor[enumName]) return ctor[enumName];
    return null;
  }

  /**********************************************************************
   * EasySeeso (사용자 제공 코드 기반, webpack import 제거/순수 JS화)
   **********************************************************************/
  class EasySeeso {
    constructor(seesoNs) {
      this._ns = seesoNs;
      const Ctor = resolveSeesoCtor(seesoNs);
      if (!Ctor) throw new Error("SeeSo SDK constructor를 찾을 수 없습니다. (CDN 로딩 실패 가능)");
      this.seeso = new Ctor();

      this.onGaze = null;
      this.onFace = null;
      this.onDebug = null;

      this.onCalibrationNextPoint = null;
      this.onCalibrationProgress = null;
      this.onCalibrationFinished = null;

      this.onAttention = null;
      this.onBlink = null;
      this.onDrowsiness = null;

      this.onGazeBind = null;
      this.onCalibrationFinishedBind = null;
    }

    async init(licenseKey, afterInitialized, afterFailed, userStatusOption) {
      const InitErr = resolveEnum(this._ns, resolveSeesoCtor(this._ns), "InitializationErrorType");

      await this.seeso.initialize(licenseKey, userStatusOption).then(function (errCode) {
        // errCode === 0(ERROR_NONE) 형태일 수도 있어 방어적으로 처리
        const ok =
          (InitErr && errCode === InitErr.ERROR_NONE) ||
          (!InitErr && (errCode === 0 || errCode === "ERROR_NONE"));

        if (ok) {
          afterInitialized();
          this.onCalibrationFinishedBind = this.onCalibrationFinished_.bind(this);
          this.seeso.addCalibrationFinishCallback(this.onCalibrationFinishedBind);

          this.onGazeBind = this.onGaze_.bind(this);
          this.seeso.addGazeCallback(this.onGazeBind);
        } else {
          afterFailed(errCode);
        }
      }.bind(this));
    }

    deinit() {
      try { this.removeUserStatusCallback(); } catch (e) {}
      try { if (this.onGazeBind) this.seeso.removeGazeCallback(this.onGazeBind); } catch (e) {}
      try { if (this.onCalibrationFinishedBind) this.seeso.removeCalibrationFinishCallback(this.onCalibrationFinishedBind); } catch (e) {}
      try { if (this.onDebug) this.seeso.removeDebugCallback(this.onDebug); } catch (e) {}
      try { this.seeso.deinitialize(); } catch (e) {}
    }

    async startTracking(onGaze, onDebug, videoElForPreview) {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true }); // Secure context 필요 :contentReference[oaicite:4]{index=4}
      if (videoElForPreview) {
        videoElForPreview.srcObject = stream;
      }

      this.seeso.addDebugCallback(onDebug);

      if (this.seeso.startTracking(stream)) {
        this.onGaze = onGaze;
        this.onDebug = onDebug;
        return true;
      } else {
        this.seeso.removeDebugCallback(this.onDebug);
        return false;
      }
    }

    stopTracking() {
      try { this.seeso.stopTracking(); } catch (e) {}
      try { if (this.onDebug) this.seeso.removeDebugCallback(this.onDebug); } catch (e) {}
      this.onGaze = null;
      this.onDebug = null;
    }

    startCalibration(onCalibrationNextPoint, onCalibrationProgress, onCalibrationFinished, calibrationPoints = 5) {
      const CalibCriteria = resolveEnum(this._ns, resolveSeesoCtor(this._ns), "CalibrationAccuracyCriteria");

      this.seeso.addCalibrationNextPointCallback(onCalibrationNextPoint);
      this.seeso.addCalibrationProgressCallback(onCalibrationProgress);

      const criteria = CalibCriteria ? CalibCriteria.Default : undefined;
      const isStart = this.seeso.startCalibration(calibrationPoints, criteria);

      if (isStart) {
        this.onCalibrationNextPoint = onCalibrationNextPoint;
        this.onCalibrationProgress = onCalibrationProgress;
        this.onCalibrationFinished = onCalibrationFinished;
      } else {
        this.seeso.removeCalibrationNextPointCallback(this.onCalibrationNextPoint);
        this.seeso.removeCalibrationProgressCallback(this.onCalibrationProgress);
      }
      return isStart;
    }

    stopCalibration() { return this.seeso.stopCalibration(); }
    startCollectSamples() { this.seeso.startCollectSamples(); }

    onGaze_(gazeInfo) { if (this.onGaze) this.onGaze(gazeInfo); }

    onCalibrationFinished_(calibrationData) {
      if (this.onCalibrationFinished) this.onCalibrationFinished(calibrationData);

      this.seeso.removeCalibrationNextPointCallback(this.onCalibrationNextPoint);
      this.seeso.removeCalibrationProgressCallback(this.onCalibrationProgress);

      this.onCalibrationFinished = null;
      this.onCalibrationProgress = null;
      this.onCalibrationNextPoint = null;
    }
  }

  /**********************************************************************
   * UI + Flow
   **********************************************************************/
  const secureBadge = $("secureBadge");
  const sdkBadge = $("sdkBadge");

  const btnStart = $("btnStart");
  const btnCalib = $("btnCalib");
  const btnStop  = $("btnStop");

  const stage = $("stage");
  const gazeDot = $("gazeDot");
  const calibDot = $("calibDot");
  const videoEl = $("video");

  let easy = null;
  let tracking = false;
  let calibrating = false;

  function setTrackingState(v) {
    tracking = v;
    setKV("kvTracking", tracking ? "ON" : "OFF");
    btnStop.disabled = !tracking;
    btnCalib.disabled = !tracking;
  }
  function setCalibState(v) {
    calibrating = v;
    setKV("kvCalib", calibrating ? "RUNNING" : "IDLE");
  }

  function placeDot(el, x, y) {
    // stage 기준 좌표가 아니라 "뷰포트" 좌표를 받을 가능성이 높아, stage의 bounding rect로 보정
    const r = stage.getBoundingClientRect();
    // (x,y)가 픽셀(뷰포트)이라면 그대로 사용
    // (x,y)가 0~1 정규화라면 stage 비율로 변환
    let px = x;
    let py = y;

    if (x >= 0 && x <= 1 && y >= 0 && y <= 1) {
      px = r.left + x * r.width;
      py = r.top  + y * r.height;
    }

    // stage 내부 좌표로 변환
    const sx = px - r.left;
    const sy = py - r.top;

    el.style.left = sx + "px";
    el.style.top  = sy + "px";
  }

  function parseXY(args) {
    // (obj) / ([x,y]) / (x,y) 모두 대응
    if (args.length === 1) {
      const a = args[0];
      if (!a) return null;
      if (typeof a === "object") {
        if ("x" in a && "y" in a) return { x: a.x, y: a.y };
        if (Array.isArray(a) && a.length >= 2) return { x: a[0], y: a[1] };
      }
      return null;
    }
    if (args.length >= 2) return { x: args[0], y: args[1] };
    return null;
  }

  function handleGaze(gazeInfo) {
    if (!gazeInfo) return;

    // 일반적으로 gazeInfo.x, gazeInfo.y 형태를 기대
    const x = gazeInfo.x ?? gazeInfo.gazeX ?? gazeInfo.screenX ?? null;
    const y = gazeInfo.y ?? gazeInfo.gazeY ?? gazeInfo.screenY ?? null;

    if (typeof x === "number" && typeof y === "number") {
      gazeDot.style.display = "block";
      placeDot(gazeDot, x, y);
      setKV("kvGaze", `${x.toFixed(1)}, ${y.toFixed(1)}`);
    }
  }

  function handleDebug(debugInfo) {
    // debugInfo 구조가 SDK 버전에 따라 다를 수 있어 최소 출력
    try {
      const s = (typeof debugInfo === "string") ? debugInfo : JSON.stringify(debugInfo);
      setKV("kvDebug", s.slice(0, 120) + (s.length > 120 ? "…" : ""));
    } catch (e) {
      setKV("kvDebug", String(debugInfo));
    }
  }

  async function initAndStart() {
    // Secure context 강제 (URL 접속 기반 목적)
    const secureOk = isHttpsOrLocalhost();
    setKV("kvOrigin", location.origin || (location.protocol + "//" + location.host));
    setKV("kvSecure", secureOk ? "YES" : "NO");
    setKV("kvCOI", window.crossOriginIsolated ? "true" : "false");

    if (secureOk) {
      setBadge(secureBadge, "Secure Context: OK (HTTPS/localhost)", "ok");
    } else {
      setBadge(secureBadge, "Secure Context: NO (HTTPS 필요)", "err");
      log("오류: HTTP/파일열기 환경에서는 카메라 퍼미션 팝업이 뜨지 않습니다. HTTPS로 배포 후 URL로 접속하세요.");
      // 여기서도 버튼은 남겨두되, 실행 시도는 막음
      return;
    }

    const ns = resolveSeesoNamespace();
    const ctor = resolveSeesoCtor(ns);
    if (!ns || !ctor) {
      setBadge(sdkBadge, "SDK: 로딩 실패 (cdn.seeso.io)", "err");
      setKV("kvSDK", "NOT FOUND");
      log("오류: SeeSo SDK 글로벌 객체를 찾지 못했습니다. (CDN 로딩 실패/차단 가능)");
      return;
    }
    setBadge(sdkBadge, "SDK: LOADED", "ok");
    setKV("kvSDK", "OK");

    // SDK init
    easy = new EasySeeso(ns);
    setTrackingState(false);
    setCalibState(false);

    // 필요 시 userStatusOption을 넣을 수 있음(옵션 구조는 SDK 버전별 상이)
    const userStatusOption = undefined;

    log("SDK initialize() 호출...");
    await easy.init(
      LICENSE_KEY,
      () => log("SDK initialize 성공"),
      (errCode) => log("SDK initialize 실패: " + errCode),
      userStatusOption
    );

    // 카메라 퍼미션 팝업을 즉시 띄우기 위해, 페이지 로드 후 바로 getUserMedia 시도
    log("카메라 getUserMedia() 요청 → 퍼미션 팝업이 떠야 정상입니다.");
    try {
      const ok = await easy.startTracking(handleGaze, handleDebug, videoEl);
      if (!ok) {
        log("startTracking 실패(반환값 false).");
        setTrackingState(false);
        return;
      }
      setTrackingState(true);
      log("Tracking 시작 성공.");

      // 자동 캘리브레이션 시작
      startCalibration5();
    } catch (e) {
      // 브라우저가 “사용자 제스처 필요” 정책으로 차단하는 경우가 있어 fallback 안내
      log("카메라 시작 실패: " + (e && e.name ? e.name + " - " : "") + (e && e.message ? e.message : String(e)));
      log("브라우저가 자동 호출을 막는 경우, 상단의 '자동 시작 재시도' 버튼을 클릭해 주세요.");
      setTrackingState(false);
    }
  }

  function startCalibration5() {
    if (!easy || !tracking) return;

    // 캘리브레이션 프로세스: 다음 포인트 좌표 수신 → 점 표시 → startCollectSamples()로 샘플 수집 :contentReference[oaicite:5]{index=5}
    setCalibState(true);
    calibDot.style.display = "block";
    gazeDot.style.display = "none";

    log("Calibration(5pt) 시작...");

    const started = easy.startCalibration(
      function (...args) {
        const xy = parseXY(args);
        if (!xy) {
          log("onCalibrationNextPoint: 좌표 파싱 실패 (args=" + args.length + ")");
          return;
        }
        placeDot(calibDot, xy.x, xy.y);

        // 점이 UI에 그려진 이후 샘플 수집 시작
        setTimeout(() => {
          try {
            easy.startCollectSamples();
          } catch (e) {
            log("startCollectSamples() 실패: " + (e && e.message ? e.message : String(e)));
          }
        }, 250);
      },
      function (progress) {
        // progress 형태가 number/obj 모두 가능하므로 방어적으로 처리
        let p = progress;
        if (typeof progress === "object" && progress !== null) {
          p = progress.progress ?? progress.percent ?? JSON.stringify(progress);
        }
        log("Calibration progress: " + p);
      },
      function (calibrationData) {
        setCalibState(false);
        calibDot.style.display = "none";
        gazeDot.style.display = "block";

        // calibrationData는 저장/재사용 가능 (필요 시 localStorage 등에 저장)
        log("Calibration finished. calibrationData length=" + (calibrationData ? String(calibrationData).length : 0));
      },
      5
    );

    if (!started) {
      setCalibState(false);
      calibDot.style.display = "none";
      log("Calibration start 실패. (startCalibration returned false)");
    }
  }

  function stopAll() {
    try {
      if (easy) {
        try { easy.stopCalibration(); } catch (e) {}
        easy.stopTracking();
        easy.deinit();
      }
    } catch (e) {}
    easy = null;
    setTrackingState(false);
    setCalibState(false);
    gazeDot.style.display = "none";
    calibDot.style.display = "none";
    log("중지 완료.");
  }

  /**********************************************************************
   * Buttons
   **********************************************************************/
  btnStart.addEventListener("click", async () => {
    log("사용자 클릭으로 재시도 시작...");
    await initAndStart();
  });

  btnCalib.addEventListener("click", () => {
    log("캘리브레이션 재시작 요청...");
    startCalibration5();
  });

  btnStop.addEventListener("click", () => {
    stopAll();
  });

  /**********************************************************************
   * Boot (자동 실행)
   **********************************************************************/
  window.addEventListener("DOMContentLoaded", async () => {
    log("페이지 로드됨. 자동 시작 시도...");
    await initAndStart();
  });
</script>
</body>
</html>
